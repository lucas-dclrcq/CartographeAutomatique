using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CartographeAutomatique;

class ClassMapping
{
    private readonly ClassDeclarationSyntax SourceClass;
    private readonly ClassDeclarationSyntax? TargetClass;

    public ClassMapping(ClassDeclarationSyntax sourceClass)
    {
        SourceClass = sourceClass;
    }

    public ClassMapping(ClassDeclarationSyntax sourceClass, ClassDeclarationSyntax targetClass)
    {
        SourceClass = sourceClass;
        TargetClass = targetClass;
    }

    public string? GenerateMapping(Compilation compilation)
    {
        if (TargetClass is null)
        {
            return null;
        }

        var sourceInstanceVar = TargetClassName.ToLower();

        var sourceProperties = new Dictionary<string, MemberDeclarationSyntax>();
        foreach (var memberDeclarationSyntax in SourceClass.Members)
        {
            if (memberDeclarationSyntax is PropertyDeclarationSyntax property)
            {
                sourceProperties.Add(property.Identifier.Text, property);
            }
        }

        List<string> assignations = [];

        foreach (var memberDeclarationSyntax in TargetClass.Members)
        {
            if (memberDeclarationSyntax is not PropertyDeclarationSyntax targetProperty) continue;
            if (!sourceProperties.TryGetValue(targetProperty.Identifier.Text, out var sourceProperty)) continue;

            var sourceType = sourceProperty.GetType();
            var targetType = targetProperty.GetType();
            if (sourceType != targetType) continue;

            assignations.Add($"""{targetProperty.Identifier.Text} = this.{targetProperty.Identifier.Text}""");
        }

        var sourceNameSpace = SourceNameSpace(compilation)!;
        var targetNameSpace = TargetNameSpace(compilation)!;

        var joinedAssignation = string.Join(",\n\t\t\t", assignations);
        return $$"""
                 // <auto-generated/>
                 namespace {{sourceNameSpace}};

                 public partial class {{SourceClassName}}
                 {
                     public {{targetNameSpace}}.{{TargetClassName}} MapTo{{TargetClassName}}() =>
                        new()
                        {
                             {{joinedAssignation}}
                        };
                 }
                 """;
    }

    private string? TargetNameSpace(Compilation compilation)
    {
        var sourceSemanticModel = compilation.GetSemanticModel(TargetClass!.SyntaxTree);
        if (sourceSemanticModel.GetDeclaredSymbol(TargetClass) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    private string TargetClassName => TargetClass!.Identifier.Text;

    private string? SourceNameSpace(Compilation compilation)
    {
        var sourceSemanticModel = compilation.GetSemanticModel(SourceClass.SyntaxTree);
        if (sourceSemanticModel.GetDeclaredSymbol(SourceClass) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    public string SourceClassName => SourceClass.Identifier.Text;
}