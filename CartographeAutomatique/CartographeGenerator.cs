using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace CartographeAutomatique;

[Generator]
public class CartographeGenerator : IIncrementalGenerator
{
    private const string Namespace = "Generators";
    private const string AttributeName = "MapToAttribute";
    
    private const string AttributeSourceCode = $@"// <auto-generated/>

namespace {Namespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class MapToAttribute : System.Attribute
    {{
        public MapToAttribute(System.Type targetClassName)
        {{
            TargetClassName = targetClassName;
        }}

        public System.Type TargetClassName {{ get; }}
    }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "MapToAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.Item2)
            .Select((t, _) => t.mapping);

        var incrementalValueProvider = provider.Collect();

        context.RegisterSourceOutput(context.CompilationProvider.Combine(incrementalValueProvider),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static (ClassMapping mapping, bool) GetClassDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        var sourceClassDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeListSyntax in sourceClassDeclarationSyntax.AttributeLists)
        foreach (var attributeArgumentSyntax in from attributeSyntax in attributeListSyntax.Attributes
                 where attributeSyntax.Name.ToString() != $"{Namespace}.{AttributeName}"
                 select attributeSyntax.ArgumentList?.Arguments.First())
        {
            if (attributeArgumentSyntax?.Expression is not TypeOfExpressionSyntax typeOfExpressionSyntax) continue;

            var targetIdentifierName = typeOfExpressionSyntax.Type as IdentifierNameSyntax;
            var targetSymbolInfo = context.SemanticModel.GetSymbolInfo(targetIdentifierName!);
            var targetClassSyntax = ClassDeclarationSyntaxFromSymbolInfo(targetSymbolInfo);

            if (targetClassSyntax is null) continue;
            
            return (new ClassMapping(sourceClassDeclarationSyntax, targetClassSyntax), true);
        }

        return (new ClassMapping(sourceClassDeclarationSyntax), false);
    }

    private static ClassDeclarationSyntax? ClassDeclarationSyntaxFromSymbolInfo(SymbolInfo targetSymbolInfo)
    {
        if (targetSymbolInfo.Symbol is not INamedTypeSymbol
            {
                DeclaringSyntaxReferences.Length: > 0
            } targetNamedType) return null;

        var node = targetNamedType.DeclaringSyntaxReferences[0].GetSyntax();
        if (node is ClassDeclarationSyntax classDeclarationSyntax)
        {
            return classDeclarationSyntax;
        }

        return null;
    }

    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassMapping> classDeclarations)
    {
        
        foreach (var classMapping in classDeclarations)
        {
            var generatedMapping = classMapping.GenerateMapping(compilation);
            if (generatedMapping is not null)
            {
                context.AddSource($"{classMapping.SourceClassName}.g.cs", SourceText.From(generatedMapping, Encoding.UTF8));

            }
        }
    }
}

class ClassMapping
{
    private readonly ClassDeclarationSyntax SourceClass;
    private readonly ClassDeclarationSyntax? TargetClass;

    public ClassMapping(ClassDeclarationSyntax sourceClass)
    {
        SourceClass = sourceClass;
    }

    public ClassMapping(ClassDeclarationSyntax sourceClass, ClassDeclarationSyntax targetClass)
    {
        SourceClass = sourceClass;
        TargetClass = targetClass;
    }

    public string? GenerateMapping(Compilation compilation)
    {
        if (TargetClass is null)
        {
            return null;
        }

        var sourceInstanceVar = TargetClassName.ToLower();
        
        var sourceProperties = new Dictionary<string, MemberDeclarationSyntax>(); 
        foreach (var memberDeclarationSyntax in SourceClass.Members)
        {
            if (memberDeclarationSyntax is PropertyDeclarationSyntax property)
            {
                sourceProperties.Add(property.Identifier.Text, property);
            }
        }

        List<string> assignations = [];
        
        foreach (var memberDeclarationSyntax in TargetClass.Members)
        {
            if (memberDeclarationSyntax is not PropertyDeclarationSyntax targetProperty) continue;
            if (!sourceProperties.TryGetValue(targetProperty.Identifier.Text, out var sourceProperty)) continue;
            
            var sourceType = sourceProperty.GetType();
            var targetType = targetProperty.GetType();
            if (sourceType != targetType) continue;

            assignations.Add($"""{targetProperty.Identifier.Text} = this.{targetProperty.Identifier.Text}""");
        }

        var sourceNameSpace = SourceNameSpace(compilation)!;
        var targetNameSpace = TargetNameSpace(compilation)!;

        var joinedAssignation = string.Join(",\n\t\t\t", assignations);
        return $$"""
                 // <auto-generated/>
                 namespace {{sourceNameSpace}};

                 public partial class {{SourceClassName}}
                 {
                     public {{targetNameSpace}}.{{TargetClassName}} MapTo{{TargetClassName}}() =>
                        new()
                        {
                             {{joinedAssignation}}
                        };
                 }
                 """;
    }
    
    private string? TargetNameSpace(Compilation compilation)
    {
        var sourceSemanticModel = compilation.GetSemanticModel(TargetClass!.SyntaxTree);
        if (sourceSemanticModel.GetDeclaredSymbol(TargetClass) is not INamedTypeSymbol sourceClassSymbol)
            return null;
        
        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }
    
    private string TargetClassName => TargetClass!.Identifier.Text;
    
    private string? SourceNameSpace(Compilation compilation)
    {
        var sourceSemanticModel = compilation.GetSemanticModel(SourceClass.SyntaxTree);
        if (sourceSemanticModel.GetDeclaredSymbol(SourceClass) is not INamedTypeSymbol sourceClassSymbol)
            return null;
        
        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }
    
    public string SourceClassName => SourceClass.Identifier.Text;
}